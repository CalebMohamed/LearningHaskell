whatIsATuple = "a static sized, collection of multitype variables declared with (a, b, c,...), they also behave as their own type so if you put them in a list they all have to be the same collection of types: [(1,2), (3,4)] is good but, [(1,2), (3,4,5)] returns an error"
noWayTheyCanDoThat = "yes way, tuples can contain lists: ([1,2], [1..10], [x | x <- [1..10], x `mod` 2 == 1])"
whenShouldIUseTuples = "use them when you know the order of the data, they are much less dynamic than lists and operations such as appending do not generalise to multiple types of tuple, also singleton tuples don't exist because they don't make sense"
canICompareTuples = "yes, like lists, when the elements of tuples can be compared they can be but mismatching sizes return an error"
neatFunctionsRelatingToPairs = "fst and snd take a pair and return the 1st and 2nd elements. zip takes two lists (can be finite and infinite) and takes ordered pairs of the corresponding elements: zip [1..] ['apple', 'orange'] = [(1, 'apple'), (2, 'orange')]"

showMeAnExampleOfAnArchetypalUseOfTuples = "the problem is finding which r.a.t. with integer sides <= 10 has perimeter 24: ### first all triangles: let triangles = [ (a,b,c) | c <- [1..10], b <- [1..10], a <- [1..10] ] ### then all right angle triangles: let triangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2] ### then perimeter 24: let triangles = [ (a,b,c) | c <- [1..10], b <- [1..c], a <- [1..b], a^2 + b^2 == c^2, a+b+c == 24] ### this is a common approach in functional programming where you take a starting set of solutions and apply transformations to those solutions to filter them to the correct one"