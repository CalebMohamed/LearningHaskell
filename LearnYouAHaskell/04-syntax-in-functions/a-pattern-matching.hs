whatIsPatternMatching = "this is where you can specify different function bodies for different input patterns"
whatIsASimpleExampleOfPatternMatching = "lucky :: (Integral a) => a -> String; lucky 7 = 'LUCKY NUMBER SEVEN!'; lucky x = 'Sorry, you're out of luck, pal'; here you repeat the function name with the input pattern and say it equals a specific function body, these are checked top to bottom and simplify other complex branching behaviour."
howCanIUsePatternMatchingInACoolerWay = "instead of just using it to catch different cases you can use it to label the inputs: addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a); addVectors (x1, y1) (x2, y2) = (x1 + x2, y1 + y2);"
patternMatchingWithUnderscored = "here's a cool thing: first :: (a, b, c) -> a; first (x, _, _) = x; here we use _ to say disregard that information but consequently we get quite a visual representation of the pattern we are using to fetch certain data."
patternMatchingInListsAndComprehensions = "in list comprehensions you can pattern match quite easily: [ a+b | (a,b) <- xs]. Then with lists you can do the following x:xs will allow you to reference x as the head of a list and xs as the rest. This is used a lot in haskell as you can then deal with each element and then pass on the rest to be dealt with recursively. You can take it a step further to x:y:z:zs but this will only match to elements with 3 or more elements."
aBriefInterruptionAboutRuntimeErrors = "to throw a runtime error you can make a function body return: error {string}"
whatAreAsPatterns = "'as patterns' are a way of pattern matching where you can still access the whole input e.g. xs@(x:y:ys)"